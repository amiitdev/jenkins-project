RUN addgroup appgroup && adduser -S appuser -G appgroup

ğŸ§© addgroup appgroup

Creates a Linux group named:

appgroup


Think:

A group = department in a company ğŸ¢
Users inside it share permissions

ğŸ§© adduser -S appuser -G appgroup
Part	Meaning
adduser	create new user
-S	system user (no password, no login shell)
appuser	username
-G appgroup	put user inside group

So we create:

User: appuser
Group: appgroup
Type: system user (for running apps only)


ğŸ›‘ Why -S important?

It prevents login:

No password
No terminal
No ssh
Only runs app

So attacker cannot log into container even if compromised.


ğŸ³ docker build -t product-api:v1 -f docker/Dockerfile .
ğŸ“ . â†’ Build Context (VERY IMPORTANT)

This dot means:

â€œSend current folder to Docker daemonâ€

So Docker can access:
Jenkins-Project/
 â”œâ”€ app/
 â”œâ”€ docker/
 â”‚   â””â”€ Dockerfile
 â”œâ”€ package.json
 â””â”€ server.js

ğŸ§  Why this matters

Docker can only COPY files that exist inside the build context.

So this works:

COPY app/ .


But this fails âŒ

COPY ../secret.env .


Because Docker cannot see outside .

ğŸ‘‰ Dot = â€œallowed files areaâ€

ğŸ·ï¸ -t product-api:v1

This gives your image a name + version

Format:

name:tag

Part	        Meaning
product-api 	image name
v1	            version (tag)

Why tagging important?

Because later you run:

docker run -p 5000:5000 product-api:v1


Or upgrade:

product-api:v2
product-api:v3


Exactly like software releases ğŸ“¦

ğŸªœ What actually happens internally

1ï¸âƒ£ Docker reads Dockerfile
2ï¸âƒ£ Sends . folder to Docker engine
3ï¸âƒ£ Runs builder stage
4ï¸âƒ£ Runs runtime stage
5ï¸âƒ£ Saves final image

Result:

docker images


Youâ€™ll see:

REPOSITORY     TAG   SIZE
product-api    v1    82MB

ğŸŒ docker network create app-network
This command creates a private LAN inside your machine.

Docker creates:

Virtual Router
Virtual DNS
Private IP range
Internal firewall

With network:

app-network
 â”œâ”€â”€ api
 â””â”€â”€ db

api â†’ db:27017 âœ… always works

Containers inside same network can talk using names, not IPs ğŸ¤¯

ğŸ§  First â€” the problem it solves

Imagine you run:

Container 1 â†’ Backend API
Container 2 â†’ Database


Without network you must connect using IP:

mongodb://172.18.0.3:27017


Butâ€¦

ğŸ‘‰ Every restart = new IP ğŸ’¥
Your app breaks.

ğŸ’¡ Docker network solution

We create a virtual office:

app-network


Now containers join it like employees in same Wi-Fi.

They can talk using container name:

mongodb://db:27017


No IP needed ğŸ¯

//////////////////
if mongo exist in different container then use this command :
# Stop the existing container
docker stop mongo

# Remove it
docker rm mongo

# Create new container with your network
docker run -d --name mongo --network app-network mongo

or Use a different name for your new container:
docker run -d --name mongo2 --network app-network mongo

ğŸ³ docker run -d --name mongo --network app-network mongo:
â€œRun a MongoDB container in background, call it mongo, and connect it to app-network.â€

â–¶ï¸ docker run

This means:

Create container from an image and start it

If object's not present locally:

mongo image


Docker will automatically download it from Docker Hub ğŸŒ

ğŸ’¤ -d (detached mode)

Run in background.

Without -d:

Terminal gets locked showing logs forever


With -d:

Container runs silently like a server
You get prompt back


So your MongoDB behaves like a real installed service.

ğŸ·ï¸ --name mongo

You assign container a permanent hostname:

mongo


Now other containers can connect using:

mongodb://mongo:27017


Not IP address âœ”

ğŸŒ --network app-network

Attach container to the private network you created earlier.

So now inside that network:

api container  â†’  mongo container
      (talks via name)


Docker automatically provides:

internal DNS

private IP

firewall isolation

ğŸ“¦ Last mongo

This is the image name (from Docker Hub)

Meaning:

Use official MongoDB server image


Equivalent to installing MongoDB in Linuxâ€¦ but instant âš¡

ğŸ§  What actually happens internally

After running command:

app-network
 â”œâ”€â”€ mongo  (database server started on port 27017)


MongoDB now listening internally:

mongodb://mongo:27017


No port expose needed yet because only backend should access it ğŸ”


ğŸ³ docker run -d \
  -p 5000:5000 \
  --network app-network \
  -e MONGO_URI=mongodb://mongo:27017/products \
  product-api:v1
â€œRun my backend image in background, expose port 5000, connect it to the same network, and give it database connection settings.â€

ğŸŒ -p 5000:5000

This connects your computer â†” container

Format:

HOST_PORT : CONTAINER_PORT


So:

localhost:5000  â†’ container:5000


Now browser can access your API:

http://localhost:5000

Browser
   â†“
Your PC port 5000
   â†“
Docker container port 5000
   â†“
NodeJS app

ğŸŒ --network app-network mongo

Attach backend to same network as MongoDB.

So now inside Docker LAN:

product-api  â†’  mongo


Your backend can safely call database.

ğŸ§  Final architecture after running
app-network (private LAN)

   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   mongo     â”‚  port 27017
   â””â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ mongodb://mongo:27017/products
         â”‚
   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ product-api â”‚  port 5000
   â””â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ localhost:5000
         â”‚
     ğŸŒ Browser
